// Generated by CoffeeScript 1.4.0
(function() {
  var Terrain;

  Terrain = function(terrainFileName, width, height, game) {
    var coll_ctx, img, terrain_ctx;
    img = this.img = new Image();
    this.collisionMask = document.createElement('canvas');
    document.getElementById("collisionmap").appendChild(this.collisionMask);
    coll_ctx = this.coll_ctx = this.collisionMask.getContext("2d");
    coll_ctx.fillStyle = "rgb(0,0,0)";
    this.terrain = document.createElement('canvas');
    terrain_ctx = this.terrain_ctx = this.terrain.getContext("2d");
    this.width = width;
    this.height = height;
    this.collisionMask.width = width;
    this.collisionMask.height = height;
    this.terrain.width = width;
    this.terrain.height = height;
    game.waitForLoading(this.img, function() {
      coll_ctx.drawImage(img, 0, 0);
      return terrain_ctx.drawImage(img, 0, 0);
    });
    return this.img.src = terrainFileName;
  };

  Terrain.curvatureVectorField = (function() {
    var fullArc, i, increment, radius, _i, _results;
    fullArc = Math.PI * 2;
    increment = Math.PI * 2 / 16;
    radius = 2;
    _results = [];
    for (i = _i = 0; 0 <= fullArc ? _i <= fullArc : _i >= fullArc; i = _i += increment) {
      _results.push([i, Math.sin(i) * radius, Math.cos(i) * radius]);
    }
    return _results;
  })();

  Terrain.prototype.detectCurvature = function(x, y) {
    var freeVectors, norm_x, norm_y, pixel, v, vector, _i, _j, _len, _len1, _ref;
    freeVectors = [];
    _ref = Terrain.curvatureVectorField;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      vector = _ref[_i];
      pixel = this.coll_ctx.getImageData(Math.round(x + vector[1]), Math.round(y + vector[2]), 1, 1).data[0];
      if (pixel === 0) {
        freeVectors.push(vector);
      }
    }
    norm_x = 0;
    norm_y = 0;
    for (_j = 0, _len1 = freeVectors.length; _j < _len1; _j++) {
      v = freeVectors[_j];
      norm_x += v[1];
      norm_y += v[2];
    }
    return [norm_x, norm_y];
  };

  Terrain.prototype.render = function(c, cam) {
    return c.drawImage(this.terrain, cam.x, cam.y, cam.width, cam.height, 0, 0, cam.width, cam.height);
  };

  Terrain.prototype.lineHit = function(x1, y1, x2, y2) {
    var data, dx, dy, error, errorCorrect, errorIncrement, height, imgData, indexCol, indexCorrect, indexRow, step, width, x, xIncrement, y, yIncrement;
    x = Math.round(Math.min(x1, x2));
    y = Math.round(Math.min(y1, y2));
    dx = Math.round(x2 - x1);
    dy = Math.round(y2 - y1);
    width = Math.abs(dx);
    height = Math.abs(dy);
    if (width === 0) {
      width = 1;
    }
    if (height === 0) {
      height = 1;
    }
    xIncrement = 4;
    yIncrement = 4 * width;
    indexRow = 0;
    indexCol = 0;
    if (height <= width) {
      step = xIncrement;
      indexCorrect = yIncrement;
      errorCorrect = width;
      errorIncrement = height;
      if (dx < 0) {
        indexCol += xIncrement * (width - 1);
        step = -step;
      }
      if (dy < 0) {
        indexRow += yIncrement * (height - 1);
        indexCorrect = -indexCorrect;
      }
    } else {
      step = yIncrement;
      indexCorrect = xIncrement;
      errorCorrect = height;
      errorIncrement = width;
      if (dx < 0) {
        indexCol += xIncrement * (width - 1);
        indexCorrect = -indexCorrect;
      }
      if (dy < 0) {
        indexRow += yIncrement * (height - 1);
        step = -step;
      }
    }
    imgData = this.coll_ctx.getImageData(x, y, width, height);
    data = imgData.data;
    error = errorCorrect;
    if (height <= width) {
      while (true) {
        if (data[indexRow + indexCol] > 0) {
          return [x + (indexCol / xIncrement), y + (indexRow / yIncrement)];
        }
        indexCol += step;
        if (indexCol >= yIncrement || indexCol < 0) {
          break;
        }
        error -= errorIncrement;
        if (error <= 0) {
          error += errorCorrect;
          indexRow += indexCorrect;
        }
        if (indexRow >= data.length || indexRow < 0) {
          break;
        }
      }
    } else {
      while (true) {
        if (data[indexRow + indexCol] > 0) {
          return [x + (indexCol / xIncrement), y + (indexRow / yIncrement)];
        }
        indexRow += step;
        if (indexRow >= data.length || indexRow < 0) {
          break;
        }
        error -= errorIncrement;
        if (error <= 0) {
          error += errorCorrect;
          indexCol += indexCorrect;
        }
        if (indexCol >= data.length || indexCol < 0) {
          break;
        }
      }
    }
    return false;
  };

  Terrain.prototype.blow = function(x, y, rad) {
    this.coll_ctx.beginPath();
    this.coll_ctx.arc(x + 0.5, y + 0.5, rad, 0, Math.PI * 2, true);
    this.coll_ctx.closePath();
    this.coll_ctx.fill();
    this.terrain_ctx.beginPath();
    this.terrain_ctx.arc(x + 0.5, y + 0.5, rad, 0, Math.PI * 2, true);
    this.terrain_ctx.closePath();
    return this.terrain_ctx.fill();
  };

  window.Terrain = Terrain;

}).call(this);
