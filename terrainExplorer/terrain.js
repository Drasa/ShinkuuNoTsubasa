// Generated by CoffeeScript 1.4.0

/* Canvas: a base class for drawing stuff.
*/


(function() {
  var A, BLACK, BLUE, CANVAS_HEIGHT, CANVAS_WIDTH, CYAN, Camera, Canvas, DOWN, Debug, ENTER, Explorer, GREEN, GameObject, HALF_PIXEL, LEFT, MAGENTA, RED, RIGHT, SPACE, Terrain, UP, WHITE, YELLOW, ZERO_VECTOR, aa, bee, camera, createVector, debug, dotProduct, floorVector, game, loader, reflectVector, render, unitVector, vectorDifference, vectorEqual, vectorLength, vectorQuotient, vectorScale, vectorSum,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Canvas = function(width, height, container) {
    this.canvas = document.createElement("canvas");
    this.canvas.width = width;
    this.canvas.height = height;
    this.ctx = this.canvas.getContext("2d");
    this.ctx.imageSmoothingEnabled = false;
    this.color = RED;
    this.ctx.translateRound = function(x, y) {
      return this.translate(Math.floor(x), Math.floor(y));
    };
    if (container != null) {
      container.appendChild(this.canvas);
    }
  };

  Canvas.prototype.drawLine = function(start_point, end_point) {
    this.ctx.strokeStyle = this.color;
    this.ctx.fillStyle = this.color;
    this.ctx.beginPath();
    start_point = vectorSum(start_point, HALF_PIXEL);
    end_point = vectorSum(end_point, HALF_PIXEL);
    this.ctx.moveTo(start_point.x, start_point.y);
    this.ctx.lineTo(end_point.x, end_point.y);
    return this.ctx.stroke();
  };

  Canvas.prototype.drawRect = function(left_top_coords, width, height) {
    this.ctx.fillStyle = this.color;
    return this.ctx.fillRect(left_top_coords.x, left_top_coords.y, width, height);
  };

  Canvas.prototype.plot = function(point) {
    this.ctx.fillStyle = this.color;
    return this.ctx.fillRect(point.x, point.y, 1, 1);
  };

  Canvas.prototype.render = function(ctx) {
    return ctx.drawImage(this.canvas, 0, 0);
  };

  Canvas.prototype.clear = function() {
    return this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  };

  Canvas.prototype.drawArrow = function(start_point, arrow) {
    var i, length, unit, _i, _results;
    unit = unitVector(arrow);
    length = vectorLength(arrow);
    _results = [];
    for (i = _i = 0; 0 <= length ? _i <= length : _i >= length; i = 0 <= length ? ++_i : --_i) {
      _results.push(this.plot(vectorSum(start_point, vectorScale(unit, i))));
    }
    return _results;
  };

  dotProduct = function(a, b) {
    return (a.x * b.x) + (a.y * b.y);
  };

  vectorSum = function(a, b) {
    return {
      x: a.x + b.x,
      y: a.y + b.y
    };
  };

  vectorDifference = function(a, b) {
    return {
      x: a.x - b.x,
      y: a.y - b.y
    };
  };

  vectorQuotient = function(a, divisor) {
    return {
      x: a.x / divisor,
      y: a.y / divisor
    };
  };

  vectorScale = function(a, multiplier) {
    return {
      x: a.x * multiplier,
      y: a.y * multiplier
    };
  };

  vectorLength = function(a) {
    return Math.sqrt(a.x * a.x + a.y * a.y);
  };

  floorVector = function(a) {
    return {
      x: Math.floor(a.x),
      y: Math.floor(a.y)
    };
  };

  vectorEqual = function(a, b) {
    if (a.x === b.x && a.y === b.y) {
      return true;
    } else {
      return false;
    }
  };

  unitVector = function(a) {
    return vectorQuotient(a, vectorLength(a));
  };

  createVector = function(direction, length) {
    return {
      x: Math.sin(direction) * length,
      y: -Math.cos(direction) * length
    };
  };

  reflectVector = function(normal, incidence, bullet) {
    var product, reflection;
    normal = unitVector(normal);
    product = dotProduct(normal, incidence);
    if (!(product > 0)) {
      reflection = vectorDifference(incidence, vectorScale(normal, 2 * product));
    } else {
      reflection = incidence;
      debug.demo(bullet);
      alert("kiven sisästä TODO");
    }
    return reflection;
  };

  GameObject = function(position, terrain, velocity) {
    if (velocity == null) {
      velocity = {
        x: 0,
        y: 0
      };
    }
    this.position = position;
    this.terrain = terrain;
    this.velocity = velocity;
    this.junnaus = 0;
    GameObject.objects.push(this);
  };

  GameObject.objects = [];

  GameObject.toBeDestroyed = [];

  GameObject.update = function() {
    var object, _i, _len, _ref, _results;
    if (GameObject.toBeDestroyed.length > 0) {
      GameObject.performDestroy();
    }
    _ref = GameObject.objects;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      object = _ref[_i];
      _results.push(object.update());
    }
    return _results;
  };

  GameObject.performDestroy = function() {
    var deadObject, index, object, _i, _len, _ref, _ref1;
    _ref = GameObject.toBeDestroyed;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      deadObject = _ref[_i];
      _ref1 = GameObject.objects;
      for (index in _ref1) {
        object = _ref1[index];
        if (object === deadObject) {
          break;
        }
      }
      GameObject.objects.splice(index, 1);
    }
    return GameObject.toBeDestroyed = [];
  };

  GameObject.render = function(ctx, canvas) {
    var object, _i, _len, _ref, _results;
    _ref = GameObject.objects;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      object = _ref[_i];
      _results.push(object.render(ctx, canvas));
    }
    return _results;
  };

  GameObject.prototype.render = function(ctx) {
    throw "This method has to be implemented!";
  };

  GameObject.prototype.update = function() {
    return this.move();
  };

  aa = {
    x: 1,
    y: 1
  };

  bee = {
    x: 1,
    y: 1
  };

  GameObject.prototype.move = function(displacement) {
    var hit_coords, last_safe, last_solid_pixel, reverse, root_of_normal, surface_normal, surplus_displacement, target_position, tip_of_normal, _ref, _ref1;
    if (displacement == null) {
      displacement = this.velocity;
    }
    if (this.junnaus > 2) {
      alert("haistakaa vittu ku junnaa pahasti");
    }
    target_position = vectorSum(this.position, displacement);
    _ref = this.terrain.lineHit(this.position, target_position), hit_coords = _ref[0], last_safe = _ref[1];
    if (!hit_coords) {
      this.position = target_position;
      this.junnaus = 0;
      return debug.clear();
    } else {
      surface_normal = this.terrain.detectCurvature(last_safe);
      surplus_displacement = vectorDifference(floorVector(target_position), last_safe);
      if (!vectorEqual(last_safe, this.position)) {
        this.position = last_safe;
        displacement = this.bounce(surface_normal, surplus_displacement);
        debug.color = RED;
        debug.plot(last_safe);
        debug.color = GREEN;
        debug.plot(hit_coords);
      } else {
        this.junnaus++;
        tip_of_normal = vectorSum(hit_coords, surface_normal);
        _ref1 = this.terrain.lineHit(hit_coords, tip_of_normal, reverse = true), root_of_normal = _ref1[0], last_solid_pixel = _ref1[1];
        debug.color = WHITE;
        debug.plot(tip_of_normal);
        debug.plot(root_of_normal);
        this.position = root_of_normal;
        if (this.junnaus > 1) {
          console.log("Last safe position: ");
          console.log(last_safe);
          console.log("Surplus displacement: ");
          console.log(surplus_displacement);
          console.log("After refl. Next displacement: ");
          console.log(displacement);
          console.log("velocity: ");
          console.log(this.velocity);
          debug.demo(this);
          alert("jun jun 2");
        }
      }
      return this.move(displacement);
    }
  };

  GameObject.prototype.bounce = function(surface_normal, surplus_displacement) {
    var displacement_reflection;
    this.velocity = reflectVector(surface_normal, this.velocity, this);
    return displacement_reflection = reflectVector(surface_normal, surplus_displacement, this);
  };

  GameObject.prototype.render = function(ctx) {
    throw "This needs to be implemented!";
  };

  GameObject.prototype.destroy = function() {
    this.destroyed = true;
    return GameObject.toBeDestroyed.push(this);
  };

  Terrain = function(terrainFileName, width, height) {
    var coll_ctx, img, terrain_ctx;
    img = this.img = new Image();
    this.collisionMask = document.createElement('canvas');
    document.getElementById("collisionmap").appendChild(this.collisionMask);
    coll_ctx = this.coll_ctx = this.collisionMask.getContext("2d");
    coll_ctx.fillStyle = "rgb(0,0,0)";
    this.terrain = document.createElement('canvas');
    terrain_ctx = this.terrain_ctx = this.terrain.getContext("2d");
    this.width = width;
    this.height = height;
    this.collisionMask.width = width;
    this.collisionMask.height = height;
    this.terrain.width = width;
    this.terrain.height = height;
    loader.asyncWaitForLoading(this.img, function() {
      coll_ctx.drawImage(img, 0, 0);
      return terrain_ctx.drawImage(img, 0, 0);
    });
    return this.img.src = terrainFileName;
  };

  Terrain.curvatureVectorField = (function() {
    var fullArc, i, increment, radius, _i, _results;
    fullArc = Math.PI * 2;
    increment = Math.PI * 2 / 16;
    radius = 2;
    _results = [];
    for (i = _i = 0; 0 <= fullArc ? _i <= fullArc : _i >= fullArc; i = _i += increment) {
      _results.push(createVector(i, radius));
    }
    return _results;
  })();

  Terrain.curvatureVectorField2 = (function() {
    var vectors, x, y, _i, _j;
    vectors = [];
    for (x = _i = -3; _i <= 3; x = ++_i) {
      for (y = _j = -3; _j <= 3; y = ++_j) {
        vectors = vectors.concat({
          x: x,
          y: y
        });
      }
    }
    return vectors;
  })();

  Terrain.prototype.detectCurvature = function(air_coords, solid_coords) {
    var freeVectors, normal, pixel, pixel_coord, v, vector, _i, _j, _len, _len1, _ref;
    freeVectors = [];
    _ref = Terrain.curvatureVectorField2;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      vector = _ref[_i];
      pixel_coord = floorVector(vectorSum(air_coords, vector));
      pixel = this.coll_ctx.getImageData(pixel_coord.x, pixel_coord.y, 1, 1).data[0];
      if (pixel === 0) {
        freeVectors.push(vector);
      }
    }
    normal = createVector(0, 0);
    for (_j = 0, _len1 = freeVectors.length; _j < _len1; _j++) {
      v = freeVectors[_j];
      normal = vectorSum(normal, v);
    }
    return normal;
  };

  Terrain.prototype.render = function(c, cam) {
    return c.drawImage(this.terrain, cam.position.x, cam.position.y, cam.width, cam.height, 0, 0, cam.width, cam.height);
  };

  Terrain.prototype.pointHit = function(coords) {
    var imgData;
    coords = floorVector(coords);
    imgData = this.coll_ctx.getImageData(coords.x, coords.y, 1, 1);
    if (imgData.data[0] > 0) {
      return coords;
    } else {
      return false;
    }
  };

  Terrain.prototype.lineHit = function(start_point, end_point, reverse) {
    var data, errorCorrect, errorIncrement, hit_point, indexCol, indexCorrect, indexRow, lastSafe, rect_height, rect_width, rect_x, rect_y, step, tolerance, xIncrement, yIncrement;
    if (reverse == null) {
      reverse = false;
    }
    rect_x = Math.floor(Math.min(start_point.x, end_point.x));
    rect_y = Math.floor(Math.min(start_point.y, end_point.y));
    rect_width = Math.round(Math.max(start_point.x, end_point.x) + 0.5) - rect_x;
    rect_height = Math.round(Math.max(start_point.y, end_point.y) + 0.5) - rect_y;
    xIncrement = 4;
    yIncrement = 4 * rect_width;
    data = this.coll_ctx.getImageData(rect_x, rect_y, rect_width, rect_height).data;
    indexRow = 0;
    indexCol = 0;
    step = xIncrement;
    indexCorrect = yIncrement;
    errorCorrect = rect_width - 1;
    errorIncrement = rect_height - 1;
    if ((end_point.x - start_point.x) < 0) {
      indexCol += xIncrement * (rect_width - 1);
      step = -step;
    }
    if ((end_point.y - start_point.y) < 0) {
      indexRow += yIncrement * (rect_height - 1);
      indexCorrect = -indexCorrect;
    }
    tolerance = (errorCorrect - errorIncrement) / 2;
    lastSafe = {
      x: NaN,
      y: NaN
    };
    hit_point = {
      x: NaN,
      y: NaN
    };
    if ((!reverse && data[indexRow + indexCol] > 0) || (reverse && data[indexRow + indexCol] === 0)) {
      hit_point.x = rect_x + (indexCol / xIncrement);
      hit_point.y = rect_y + (indexRow / yIncrement);
      return [hit_point, lastSafe];
    } else {
      lastSafe.x = rect_x + (indexCol / xIncrement);
      lastSafe.y = rect_y + (indexRow / yIncrement);
    }
    while (true) {
      while (!(tolerance > 0)) {
        if ((!reverse && data[indexRow + indexCol] > 0) || (reverse && data[indexRow + indexCol] === 0)) {
          hit_point.x = rect_x + (indexCol / xIncrement);
          hit_point.y = rect_y + (indexRow / yIncrement);
          return [hit_point, lastSafe];
        } else {
          lastSafe.x = rect_x + (indexCol / xIncrement);
          lastSafe.y = rect_y + (indexRow / yIncrement);
        }
        tolerance += errorCorrect;
        indexRow += indexCorrect;
        if (indexRow < 0 || indexRow >= data.length) {
          break;
        }
      }
      indexCol += step;
      tolerance -= errorIncrement;
      if (indexCol >= yIncrement || indexCol < 0) {
        break;
      }
      if ((!reverse && data[indexRow + indexCol] > 0) || (reverse && data[indexRow + indexCol] === 0)) {
        hit_point.x = rect_x + (indexCol / xIncrement);
        hit_point.y = rect_y + (indexRow / yIncrement);
        return [hit_point, lastSafe];
      } else {
        lastSafe.x = rect_x + (indexCol / xIncrement);
        lastSafe.y = rect_y + (indexRow / yIncrement);
      }
    }
    return false;
  };

  Terrain.prototype.blow = function(coords, radius) {
    this.coll_ctx.beginPath();
    this.coll_ctx.arc(coords.x + 0.5, coords.y + 0.5, radius, 0, Math.PI * 2, true);
    this.coll_ctx.closePath();
    this.coll_ctx.fill();
    this.terrain_ctx.beginPath();
    this.terrain_ctx.arc(coords.x + 0.5, coords.y + 0.5, radius, 0, Math.PI * 2, true);
    this.terrain_ctx.closePath();
    return this.terrain_ctx.fill();
  };

  Explorer = function(position, terrain) {
    Explorer.__super__.constructor.call(this, position, terrain);
  };

  __extends(Explorer, GameObject);

  Explorer.prototype.render = function(ctx, canvas) {
    canvas.plot(this.position);
    return canvas.drawArrow(this.position, this.terrain.detectCurvature(this.position));
  };

  /* Camera: a movable object which points to the centre of the place that is supposed to be "on-screen"
  */


  Camera = function(position, viewport_width, viewport_height, terrain) {
    this.position = position;
    this.width = viewport_width;
    this.height = viewport_height;
    this.terrain = terrain;
  };

  Camera.prototype.focusTo = function(coords) {
    var x, y;
    x = coords.x - (this.width / 2);
    y = coords.y - (this.height / 2);
    if (x < 0) {
      x = 0;
    }
    if (x + this.width > this.terrain.width) {
      x = this.terrain.width - this.width;
    }
    if (y < 0) {
      y = 0;
    }
    if (y + this.height > this.terrain.height) {
      y = this.terrain.height - this.height;
    }
    return this.position = floorVector({
      x: x,
      y: y
    });
  };

  /* loader: keeps list of things that have to load before the game can start
  */


  loader = function(start) {
    var asyncWaitForLoading, runIfReady, waitList;
    waitList = [];
    asyncWaitForLoading = function(object, callback) {
      waitList.push(object);
      object.ready = false;
      return object.onload = function() {
        object.ready = true;
        if (callback != null) {
          callback(object);
        }
        return runIfReady();
      };
    };
    runIfReady = function() {
      var object, _i, _len;
      for (_i = 0, _len = waitList.length; _i < _len; _i++) {
        object = waitList[_i];
        if (!object.ready) {
          return false;
        }
      }
      return start();
    };
    return {
      asyncWaitForLoading: asyncWaitForLoading,
      runIfReady: runIfReady
    };
  };

  window.requestAnimFrame = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
      return window.setTimeout(callback, 1000 / 60);
    };
  })();

  /* Constant values
  */


  LEFT = 37;

  UP = 38;

  RIGHT = 39;

  DOWN = 40;

  SPACE = 32;

  ENTER = 13;

  A = 65;

  CANVAS_WIDTH = 160;

  CANVAS_HEIGHT = 120;

  ZERO_VECTOR = {
    x: 0,
    y: 0
  };

  HALF_PIXEL = {
    x: 0.5,
    y: 0.5
  };

  RED = "#FF0000";

  GREEN = "#00FF00";

  BLUE = "#0000FF";

  CYAN = "#00FFFF";

  MAGENTA = "#FF00FF";

  YELLOW = "#FFFF00";

  WHITE = "#FFFFFF";

  BLACK = "#000000";

  /* Debug: a canvas for drawing overlay debug information, graphs etc.
  */


  Debug = function(w, h) {
    return Debug.__super__.constructor.call(this, w, h);
  };

  __extends(Debug, Canvas);

  Debug.prototype.demo = function(bullet) {
    this.color = RED;
    bullet.demo = true;
    this.plot(bullet.position);
    camera.focusTo(bullet.position);
    this.drawArrow(bullet.position, bullet.velocity);
    return render();
  };

  /* game: a container object for the basic game logic
  */


  game = function(canvas_container) {
    /* Runtime logic
    */

    var cam, canvas, commands, ctx, debug, explorer, keys, logic, render, terrain, tick;
    keys = {};
    commands = (function() {
      var cmd;
      cmd = {};
      cmd[UP] = function() {
        return explorer.move({
          x: 0,
          y: -1
        });
      };
      cmd[DOWN] = function() {
        return explorer.move({
          x: 0,
          y: 1
        });
      };
      cmd[LEFT] = function() {
        return explorer.move({
          x: -1,
          y: 0
        });
      };
      cmd[RIGHT] = function() {
        return explorer.move({
          x: 1,
          y: 0
        });
      };
      cmd[SPACE] = function() {
        return player.shoot();
      };
      cmd[ENTER] = function() {
        return player.velocity = {
          x: 0,
          y: 0
        };
      };
      cmd[A] = function() {
        return debug.clear();
      };
      return cmd;
    })();
    logic = function() {
      var action, key;
      for (key in commands) {
        action = commands[key];
        if (keys[key]) {
          action();
        }
      }
      GameObject.update();
      return cam.focusTo(explorer.position);
    };
    render = function() {
      ctx.save();
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      terrain.render(ctx, cam);
      ctx.translateRound(-cam.position.x, -cam.position.y);
      GameObject.render(ctx, canvas);
      debug.render(ctx);
      return ctx.restore();
    };
    tick = function() {
      logic();
      render();
      return requestAnimFrame(tick);
    };
    /* Initialization
    */

    $(document).keydown(function(eventInfo) {
      return keys[eventInfo.which] = true;
    });
    $(document).keyup(function(eventInfo) {
      return keys[eventInfo.which] = false;
    });
    canvas = new Canvas(CANVAS_WIDTH, CANVAS_HEIGHT, canvas_container);
    ctx = canvas.ctx;
    loader = loader(tick);
    loader.asyncWaitForLoading(game);
    terrain = new Terrain("img/terrain2.png", 1400, 1000);
    debug = new Debug(terrain.width, terrain.height);
    explorer = new Explorer({
      x: 20,
      y: 100
    }, terrain);
    cam = new Camera({
      x: 60,
      y: 60
    }, CANVAS_WIDTH, CANVAS_HEIGHT, terrain);
    game.onload();
    return [debug, render, cam];
  };

  debug = null;

  render = null;

  camera = null;

  $(document).ready(function() {
    var container, _ref;
    container = document.getElementById("terrainexplorer");
    return _ref = game(container), debug = _ref[0], render = _ref[1], camera = _ref[2], _ref;
  });

}).call(this);
