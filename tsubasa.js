// Generated by CoffeeScript 1.4.0

/* Canvas: a base class for drawing stuff.
*/


(function() {
  var A, BLACK, BLUE, Bullet, CANVAS_HEIGHT, CANVAS_WIDTH, CYAN, Camera, Canvas, DOWN, Debug, ENTER, FULL_ARC, GREEN, GameObject, HALF_PIXEL, LEFT, MAGENTA, NULL_VECTOR, RED, RIGHT, SPACE, Ship, Terrain, UP, Vector, VectorByDirection, WHITE, YELLOW, camera, debug, game, loader, render,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Canvas = function(size, container) {
    this.canvas = document.createElement("canvas");
    this.canvas.width = size.x;
    this.canvas.height = size.y;
    this.ctx = this.canvas.getContext("2d");
    this.ctx.imageSmoothingEnabled = false;
    this.color = RED;
    this.ctx.translateRound = function(coords) {
      coords = coords.floor();
      return this.translate(coords.x, coords.y);
    };
    if (container != null) {
      container.appendChild(this.canvas);
    }
  };

  Canvas.prototype.drawLine = function(start_point, end_point) {
    this.ctx.strokeStyle = this.color;
    this.ctx.fillStyle = this.color;
    this.ctx.beginPath();
    start_point = start_point.plus(HALF_PIXEL);
    end_point = end_point.plus(HALF_PIXEL);
    this.ctx.moveTo(start_point.x, start_point.y);
    this.ctx.lineTo(end_point.x, end_point.y);
    return this.ctx.stroke();
  };

  Canvas.prototype.drawRect = function(left_top_coords, size) {
    this.ctx.fillStyle = this.color;
    return this.ctx.fillRect(left_top_coords.x, left_top_coords.y, size.x, size.y);
  };

  Canvas.prototype.plot = function(point) {
    this.ctx.fillStyle = this.color;
    return this.ctx.fillRect(point.x, point.y, 1, 1);
  };

  Canvas.prototype.render = function(ctx, cam) {
    return ctx.drawImage(this.canvas, cam.position.x, cam.position.y, cam.size.x, cam.size.y, 0, 0, cam.size.x, cam.size.y);
  };

  Canvas.prototype.clear = function() {
    return this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  };

  Canvas.prototype.drawArrow = function(start_point, arrow) {
    var i, unit, _i, _ref, _results;
    unit = arrow.unit();
    _results = [];
    for (i = _i = 0, _ref = arrow.length(); 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(this.plot(start_point.plus(unit.scaledBy(i))));
    }
    return _results;
  };

  GameObject = function(position, terrain, velocity) {
    if (velocity == null) {
      velocity = new Vector(0, 0);
    }
    this.position = position;
    this.terrain = terrain;
    this.velocity = velocity;
    this.junnaus = 0;
    GameObject.objects.push(this);
  };

  GameObject.objects = [];

  GameObject.toBeDestroyed = [];

  GameObject.update = function() {
    var object, _i, _len, _ref, _results;
    if (GameObject.toBeDestroyed.length > 0) {
      GameObject.performDestroy();
    }
    _ref = GameObject.objects;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      object = _ref[_i];
      _results.push(object.update());
    }
    return _results;
  };

  GameObject.performDestroy = function() {
    var deadObject, index, object, _i, _len, _ref, _ref1;
    _ref = GameObject.toBeDestroyed;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      deadObject = _ref[_i];
      _ref1 = GameObject.objects;
      for (index in _ref1) {
        object = _ref1[index];
        if (object === deadObject) {
          break;
        }
      }
      GameObject.objects.splice(index, 1);
    }
    return GameObject.toBeDestroyed = [];
  };

  GameObject.render = function(ctx) {
    var object, _i, _len, _ref, _results;
    _ref = GameObject.objects;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      object = _ref[_i];
      _results.push(object.render(ctx));
    }
    return _results;
  };

  GameObject.prototype.render = function(ctx) {
    throw "This method has to be implemented!";
  };

  GameObject.prototype.update = function() {
    return this.move();
  };

  GameObject.prototype.move = function(displacement) {
    var hit_coords, last_safe, last_solid_pixel, reverse, root_of_normal, surface_normal, surplus_displacement, target_position, tip_of_normal, _ref, _ref1;
    if (this.junnaus > 2) {
      alert("haistakaa vittu ku junnaa pahasti");
    }
    if (displacement == null) {
      displacement = this.velocity.scaledBy(game.delta_time);
    }
    target_position = this.position.plus(displacement);
    _ref = this.terrain.lineHit(this.position, target_position), hit_coords = _ref[0], last_safe = _ref[1];
    if (!hit_coords) {
      this.position = target_position;
      return this.junnaus = 0;
    } else {
      surface_normal = this.terrain.detectCurvature(last_safe, hit_coords);
      surplus_displacement = target_position.floor().minus(last_safe);
      if (!last_safe.equals(this.position)) {
        this.position = last_safe;
        displacement = this.bounce(surface_normal, surplus_displacement);
      } else {
        this.junnaus++;
        tip_of_normal = hit_coords.plus(surface_normal);
        _ref1 = this.terrain.lineHit(hit_coords.plus(HALF_PIXEL), tip_of_normal.plus(HALF_PIXEL), reverse = true), root_of_normal = _ref1[0], last_solid_pixel = _ref1[1];
        this.position = root_of_normal;
        if (this.junnaus > 1) {
          console.log("Last safe position: ");
          console.log(last_safe);
          console.log("Surplus displacement: ");
          console.log(surplus_displacement);
          console.log("After refl. Next displacement: ");
          console.log(displacement);
          console.log("velocity: ");
          console.log(this.velocity);
          alert("jun jun 2");
        }
      }
      return this.move(displacement);
    }
  };

  GameObject.prototype.bounce = function(surface_normal, surplus_displacement) {
    var displacement_reflection;
    this.velocity = this.velocity.reflectWith(surface_normal);
    return displacement_reflection = surplus_displacement.reflectWith(surface_normal);
  };

  GameObject.prototype.render = function(ctx) {
    throw "This needs to be implemented!";
  };

  GameObject.prototype.destroy = function() {
    this.destroyed = true;
    return GameObject.toBeDestroyed.push(this);
  };

  Vector = function(x, y) {
    this.x = x;
    return this.y = y;
  };

  VectorByDirection = function(direction, length) {
    return VectorByDirection.__super__.constructor.call(this, Math.sin(direction) * length, -Math.cos(direction) * length);
  };

  __extends(VectorByDirection, Vector);

  Vector.prototype.dot = function(that) {
    return (this.x * that.x) + (this.y * that.y);
  };

  Vector.prototype.plus = function(that) {
    return new Vector(this.x + that.x, this.y + that.y);
  };

  Vector.prototype.minus = function(that) {
    return new Vector(this.x - that.x, this.y - that.y);
  };

  Vector.prototype.per = function(divisor) {
    return new Vector(this.x / divisor, this.y / divisor);
  };

  Vector.prototype.scaledBy = function(multiplier) {
    return new Vector(this.x * multiplier, this.y * multiplier);
  };

  Vector.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  };

  Vector.prototype.floor = function() {
    return new Vector(Math.floor(this.x), Math.floor(this.y));
  };

  Vector.prototype.unit = function() {
    return this.per(this.length());
  };

  Vector.prototype.toString = function() {
    return "x: " + this.x + " y: " + this.y;
  };

  Vector.prototype.equals = function(that) {
    return this.x === that.x && this.y === that.y;
  };

  Vector.prototype.reflectWith = function(normal) {
    var product, reflection;
    normal = normal.unit();
    product = this.dot(normal);
    if (!(product > 0)) {
      reflection = this.minus(normal.scaledBy(2 * product));
    } else {
      reflection = this;
    }
    return reflection;
  };

  Terrain = function(terrainFileName, size) {
    var coll_ctx, img, terrain_ctx;
    img = this.img = new Image();
    this.collisionMask = document.createElement('canvas');
    document.getElementById("collisionmap").appendChild(this.collisionMask);
    coll_ctx = this.coll_ctx = this.collisionMask.getContext("2d");
    coll_ctx.fillStyle = "rgb(0,0,0)";
    this.terrain = document.createElement('canvas');
    terrain_ctx = this.terrain_ctx = this.terrain.getContext("2d");
    this.size = size;
    this.collisionMask.width = size.x;
    this.collisionMask.height = size.y;
    this.terrain.width = size.x;
    this.terrain.height = size.y;
    loader.asyncWaitForLoading(this.img, function() {
      coll_ctx.drawImage(img, 0, 0);
      return terrain_ctx.drawImage(img, 0, 0);
    });
    return this.img.src = terrainFileName;
  };

  Terrain.curvatureVectorField = (function() {
    var direction, increment, radius, _i, _results;
    increment = Math.PI * 2 / 16;
    radius = 2;
    _results = [];
    for (direction = _i = 0; 0 <= FULL_ARC ? _i <= FULL_ARC : _i >= FULL_ARC; direction = _i += increment) {
      _results.push(new VectorByDirection(direction, radius));
    }
    return _results;
  })();

  Terrain.curvatureVectorField2 = (function() {
    var vectors, x, y, _i, _j;
    vectors = [];
    for (x = _i = -3; _i <= 3; x = ++_i) {
      for (y = _j = -3; _j <= 3; y = ++_j) {
        vectors = vectors.concat(new Vector(x, y));
      }
    }
    return vectors;
  })();

  Terrain.prototype.detectCurvature = function(air_coords, solid_coords) {
    var freeVectors, normal, pixel, pixel_coord, v, vector, _i, _j, _len, _len1, _ref;
    freeVectors = [];
    _ref = Terrain.curvatureVectorField2;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      vector = _ref[_i];
      pixel_coord = (air_coords.plus(vector)).floor();
      pixel = this.coll_ctx.getImageData(pixel_coord.x, pixel_coord.y, 1, 1).data[0];
      if (pixel === 0) {
        freeVectors.push(vector);
      }
    }
    normal = new Vector(0, 0);
    for (_j = 0, _len1 = freeVectors.length; _j < _len1; _j++) {
      v = freeVectors[_j];
      normal = normal.plus(v);
    }
    return normal;
  };

  Terrain.prototype.pointHit = function(coords) {
    var imgData;
    coords = coords.floor();
    imgData = this.coll_ctx.getImageData(coords.x, coords.y, 1, 1);
    if (imgData.data[0] > 0) {
      return coords;
    } else {
      return false;
    }
  };

  Terrain.prototype.lineHit = function(start_point, end_point, reverse) {
    var data, errorCorrect, errorIncrement, hit_point, indexCol, indexCorrect, indexRow, lastSafe, rect_height, rect_width, rect_x, rect_y, step, tolerance, xIncrement, yIncrement;
    if (reverse == null) {
      reverse = false;
    }
    rect_x = Math.floor(Math.min(start_point.x, end_point.x));
    rect_y = Math.floor(Math.min(start_point.y, end_point.y));
    rect_width = Math.round(Math.max(start_point.x, end_point.x) + 0.5) - rect_x;
    rect_height = Math.round(Math.max(start_point.y, end_point.y) + 0.5) - rect_y;
    xIncrement = 4;
    yIncrement = 4 * rect_width;
    data = this.coll_ctx.getImageData(rect_x, rect_y, rect_width, rect_height).data;
    indexRow = 0;
    indexCol = 0;
    step = xIncrement;
    indexCorrect = yIncrement;
    errorCorrect = rect_width - 1;
    errorIncrement = rect_height - 1;
    if ((end_point.x - start_point.x) < 0) {
      indexCol += xIncrement * (rect_width - 1);
      step = -step;
    }
    if ((end_point.y - start_point.y) < 0) {
      indexRow += yIncrement * (rect_height - 1);
      indexCorrect = -indexCorrect;
    }
    tolerance = (errorCorrect - errorIncrement) / 2;
    lastSafe = new Vector(NaN, NaN);
    hit_point = new Vector(NaN, NaN);
    if ((!reverse && data[indexRow + indexCol] > 0) || (reverse && data[indexRow + indexCol] === 0)) {
      hit_point.x = rect_x + (indexCol / xIncrement);
      hit_point.y = rect_y + (indexRow / yIncrement);
      return [hit_point, lastSafe];
    } else {
      lastSafe.x = rect_x + (indexCol / xIncrement);
      lastSafe.y = rect_y + (indexRow / yIncrement);
    }
    while (true) {
      while (!(tolerance > 0)) {
        if ((!reverse && data[indexRow + indexCol] > 0) || (reverse && data[indexRow + indexCol] === 0)) {
          hit_point.x = rect_x + (indexCol / xIncrement);
          hit_point.y = rect_y + (indexRow / yIncrement);
          return [hit_point, lastSafe];
        } else {
          lastSafe.x = rect_x + (indexCol / xIncrement);
          lastSafe.y = rect_y + (indexRow / yIncrement);
        }
        tolerance += errorCorrect;
        indexRow += indexCorrect;
        if (indexRow < 0 || indexRow >= data.length) {
          break;
        }
      }
      indexCol += step;
      tolerance -= errorIncrement;
      if (indexCol >= yIncrement || indexCol < 0) {
        break;
      }
      if ((!reverse && data[indexRow + indexCol] > 0) || (reverse && data[indexRow + indexCol] === 0)) {
        hit_point.x = rect_x + (indexCol / xIncrement);
        hit_point.y = rect_y + (indexRow / yIncrement);
        return [hit_point, lastSafe];
      } else {
        lastSafe.x = rect_x + (indexCol / xIncrement);
        lastSafe.y = rect_y + (indexRow / yIncrement);
      }
    }
    return false;
  };

  Terrain.prototype.blow = function(coords, radius) {
    coords = coords.plus(HALF_PIXEL);
    this.coll_ctx.beginPath();
    this.coll_ctx.arc(coords.x, coords.y, radius, 0, FULL_ARC, true);
    this.coll_ctx.closePath();
    this.coll_ctx.fill();
    this.terrain_ctx.beginPath();
    this.terrain_ctx.arc(coords.x, coords.y, radius, 0, FULL_ARC, true);
    this.terrain_ctx.closePath();
    return this.terrain_ctx.fill();
  };

  Ship = function(position, terrain) {
    Ship.__super__.constructor.call(this, position, terrain);
    this.rotation = 0;
    this.width = 16;
    this.height = 16;
    this.xAnimOffset = Math.round(-0.5 * this.width);
    this.yAnimOffset = Math.round(-0.5 * this.height);
    this.loadingBullet = 0;
    this.img = new Image();
    loader.asyncWaitForLoading(this.img);
    this.img.src = "img/v.png";
  };

  __extends(Ship, GameObject);

  Ship.prototype.update = function() {
    this.move();
    return this.loadingBullet - game.delta_time;
  };

  Ship.prototype.render = function(ctx) {
    ctx.save();
    ctx.translateRound(this.position.x, this.position.y);
    ctx.rotate(this.rotation);
    ctx.drawImage(this.img, this.xAnimOffset, this.yAnimOffset);
    return ctx.restore();
  };

  Ship.prototype.acc = function(amount) {
    var acceleration;
    amount *= game.delta_time;
    acceleration = new VectorByDirection(this.rotation, amount);
    return this.velocity = this.velocity.plus(acceleration);
  };

  Ship.prototype.dec = function(amount) {
    var acceleration;
    amount *= game.delta_time;
    acceleration = new VectorByDirection(this.rotation, -amount);
    return this.velocity = this.velocity.plus(acceleration);
  };

  Ship.prototype.rotate = function(amount) {
    amount = amount * game.delta_time;
    return this.rotation += amount;
  };

  Ship.prototype.shoot = function() {
    if (this.loadingBullet < 0) {
      new Bullet(this.position, this.velocity, 40, this.rotation, this.terrain);
      return this.loadingBullet = 1;
    }
  };

  Bullet = function(position, parent_velocity, speed, direction, terrain) {
    Bullet.__super__.constructor.call(this, position, terrain);
    this.velocity = parent_velocity.plus(new VectorByDirection(direction, speed));
    this.lifespan = 10;
    this.lifestack = [this.position];
    this.renderstack = [this.position];
  };

  __extends(Bullet, GameObject);

  Bullet.prototype.update = function() {
    this.move();
    return this.clean();
  };

  Bullet.prototype.move = function(displacement) {
    this.renderstack.push(this.position);
    this.lifestack.push(this.position);
    Bullet.__super__.move.call(this, displacement);
    if (!(this.lifespan < 0)) {
      this.renderstack.push(this.position);
      return this.lifestack.push(this.position);
    }
  };

  Bullet.prototype.bounce = function(a, b) {
    var displacement;
    this.lifespan--;
    this.renderstack.push(this.position);
    this.lifestack.push(this.position);
    displacement = Bullet.__super__.bounce.call(this, a, b);
    return displacement;
  };

  Bullet.prototype.render = function(ctx) {
    var coords, point, stack, start_point, _i, _len, _ref;
    stack = this.renderstack;
    if (this.demo != null) {
      console.log("rendering lifepath");
      stack = this.lifestack;
      console.log(stack);
    }
    ctx.beginPath();
    ctx.strokeStyle = "rgb(255,255,255)";
    start_point = stack[0].floor().plus(HALF_PIXEL);
    ctx.moveTo(start_point.x, start_point.y);
    _ref = stack.slice(1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      coords = _ref[_i];
      point = coords.floor().plus(HALF_PIXEL);
      ctx.lineTo(point.x, point.y);
    }
    ctx.stroke();
    return this.renderstack = [this.position];
  };

  Bullet.prototype.clean = function() {
    if (this.position.x < 0) {
      this.destroy();
      return;
    }
    if (this.position.y < 0) {
      this.destroy();
      return;
    }
    if (this.position.x > this.terrain.width) {
      this.destroy();
      return;
    }
    if (this.position.y > this.terrain.height) {
      this.destroy();
      return;
    }
    if (this.lifespan < 0) {
      return this.destroy();
    }
  };

  /* Camera: a movable object which points to the centre of the place that is supposed to be "on-screen"
  */


  Camera = function(viewport_size, terrain) {
    this.position = new Vector(0, 0);
    this.size = viewport_size;
    this.terrain = terrain;
  };

  Camera.prototype.focusTo = function(coords) {
    var x, y;
    x = coords.x - (this.size.x / 2);
    y = coords.y - (this.size.y / 2);
    if (x < 0) {
      x = 0;
    }
    if (x + this.width > this.terrain.width) {
      x = this.terrain.width - this.width;
    }
    if (y < 0) {
      y = 0;
    }
    if (y + this.height > this.terrain.height) {
      y = this.terrain.height - this.height;
    }
    return this.position = new Vector(x, y).floor();
  };

  Camera.prototype.render = function(ctx) {
    ctx.save();
    ctx.drawImage(this.terrain.terrain, this.position.x, this.position.y, this.size.x, this.size.y, 0, 0, this.size.x, this.size.y);
    ctx.translateRound(-this.position.x, -this.position.y);
    GameObject.render(ctx);
    return ctx.restore();
  };

  /* loader: keeps list of things that have to load before the game can start
  */


  loader = function(start) {
    var asyncWaitForLoading, runIfReady, waitList;
    waitList = [];
    asyncWaitForLoading = function(object, callback) {
      waitList.push(object);
      object.ready = false;
      return object.onload = function() {
        object.ready = true;
        if (callback != null) {
          callback(object);
        }
        return runIfReady();
      };
    };
    runIfReady = function() {
      var object, _i, _len;
      for (_i = 0, _len = waitList.length; _i < _len; _i++) {
        object = waitList[_i];
        if (!object.ready) {
          return false;
        }
      }
      return start();
    };
    return {
      asyncWaitForLoading: asyncWaitForLoading,
      runIfReady: runIfReady
    };
  };

  window.requestAnimFrame = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
      return window.setTimeout(callback, 1000 / 60);
    };
  })();

  /* Constant values
  */


  LEFT = 37;

  UP = 38;

  RIGHT = 39;

  DOWN = 40;

  SPACE = 32;

  ENTER = 13;

  A = 65;

  CANVAS_WIDTH = 320;

  CANVAS_HEIGHT = 240;

  NULL_VECTOR = new Vector(0, 0);

  HALF_PIXEL = new Vector(0.5, 0.5);

  FULL_ARC = Math.PI * 2;

  RED = "#FF0000";

  GREEN = "#00FF00";

  BLUE = "#0000FF";

  CYAN = "#00FFFF";

  MAGENTA = "#FF00FF";

  YELLOW = "#FFFF00";

  WHITE = "#FFFFFF";

  BLACK = "#000000";

  /* Debug: a canvas for drawing overlay debug information, graphs etc.
  */


  Debug = function(width, height) {
    Debug.__super__.constructor.call(this, width, height);
    return this.color = RED;
  };

  __extends(Debug, Canvas);

  Debug.prototype.demo = function(bullet) {
    this.color = RED;
    bullet.demo = true;
    this.plot(bullet.position);
    camera.focusTo(bullet.position);
    this.drawArrow(bullet.position, bullet.velocity);
    return render();
  };

  Debug.prototype.showLines = function() {
    var x, y, _i, _results;
    _results = [];
    for (x = _i = -10; _i <= 10; x = ++_i) {
      _results.push((function() {
        var _j, _results1;
        _results1 = [];
        for (y = _j = -10; _j <= 10; y = ++_j) {
          _results1.push(terrain.lineHit(150 + (x * 12), 150 + (y * 12), 150 + (x * 12) + x, 150 + (y * 12) + y));
        }
        return _results1;
      })());
    }
    return _results;
  };

  /* game: a container object for the basic game logic
  */


  game = function(canvas_container) {
    /* Runtime logic
    */

    var cam, canvas, commands, ctx, keys, logic, player, render, terrain, tick, updateFPS;
    keys = {};
    commands = (function() {
      var cmd;
      cmd = {};
      cmd[UP] = function() {
        return player.acc(150);
      };
      cmd[DOWN] = function() {
        return player.dec(150);
      };
      cmd[LEFT] = function() {
        return player.rotate(-3);
      };
      cmd[RIGHT] = function() {
        return player.rotate(3);
      };
      cmd[SPACE] = function() {
        return player.shoot();
      };
      cmd[ENTER] = function() {
        return player.velocity = NULL_VECTOR;
      };
      cmd[A] = function() {
        return debug.clear();
      };
      return cmd;
    })();
    logic = function() {
      var action, key;
      for (key in commands) {
        action = commands[key];
        if (keys[key]) {
          action();
        }
      }
      GameObject.update();
      return cam.focusTo(player.position);
    };
    render = function() {
      cam.render(ctx);
      ctx.fillStyle = "#FFFFFF";
      ctx.fillText(game.fps, 10, 10);
      return ctx.fillText(player.velocity, 10, 30);
    };
    updateFPS = function() {
      var elapsed_time;
      elapsed_time = (new Date().getTime() - game.last_fps_update_time) / 1000;
      game.last_fps_update_time = game.tick_time;
      game.fps = Math.round(game.elapsed_tick_count / elapsed_time);
      return game.elapsed_tick_count = 0;
    };
    tick = function() {
      requestAnimFrame(tick);
      game.delta_time = (new Date().getTime() - game.tick_time) / 1000;
      game.tick_time = new Date().getTime();
      game.elapsed_tick_count++;
      logic();
      return render();
    };
    /* Initialization
    */

    document.addEventListener("keydown", (function(eventInfo) {
      return keys[eventInfo.which] = true;
    }), false);
    document.addEventListener("keyup", (function(eventInfo) {
      return keys[eventInfo.which] = false;
    }), false);
    canvas = document.createElement("canvas");
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;
    ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = false;
    ctx.webkitImageSmoothingEnabled = false;
    canvas_container.appendChild(canvas);
    ctx.translateRound = function(x, y) {
      return this.translate(Math.floor(x), Math.floor(y));
    };
    loader = loader(tick);
    loader.asyncWaitForLoading(game);
    terrain = new Terrain("img/terrain2.png", new Vector(1400, 1000));
    player = new Ship(new Vector(20, 100), terrain);
    cam = new Camera(new Vector(CANVAS_WIDTH, CANVAS_HEIGHT), terrain);
    game.tick_time = new Date().getTime();
    game.elapsed_tick_count = 0;
    game.fps = 0;
    game.last_fps_update_time = 0;
    setInterval(updateFPS, 500);
    game.onload();
    return [debug, render, cam];
  };

  debug = null;

  render = null;

  camera = null;

  $(document).ready(function() {
    var container, _ref;
    container = document.getElementById("shinkuunotsubasa");
    return _ref = game(container), debug = _ref[0], render = _ref[1], camera = _ref[2], _ref;
  });

}).call(this);
